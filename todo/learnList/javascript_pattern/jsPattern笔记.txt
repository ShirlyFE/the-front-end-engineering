软件开发中，模式就是一类问题的解决方案

是一种最佳实践，一种抽象

console.dir输出的是对象的结构，比如console.dir({one:1, two: {three: 3}}),这种方式还是比较good的
可维护性的代码必然是：
• Is readable-----可读的
• Is consistent------一致的
• Is predictable-------可预测的
• Looks as if it was w------容易理解的
• Is documented------有文档的



1.全局变量的陷阱
function foo() {
    var a = b =0;//其中a是local变量，b是global变量，因为其从右至左的执行顺序var a = (b = 0);也就是说先执行b=0，b是全局变量，再将b=0的返回值赋给声明了的a，因此a是局部变量
}
改进：
function foo() {
    var a, b;
    a = b =0;
}
避免全局变量可以使你的代码运行在不同的环境时不会覆盖原环境的变量对象值。而产生意想不到的bug

使用var定义的全局变量不会被deleted，隐式的全局(未使用var，在function内部或者全局环境下)变量可以被deleted（浏览器的实现有不同，firefox下变量可以删除，Chrome下不可以）

这说明隐式创建的全局变量不是真正的变量，但是他们是global对象的属性，属性可以被delete操作符deleted，但是变量不可以：

在ES5的严格模式下，隐式创建的全局变量（未定义的变量）会抛出异常


不同的环境下global对象的叫法可能不一样，比如浏览器中是window，其他的环境可能是别的名字或者不可编程访问，那么就可以通过下面方法获取全局变量
var global = (function() {
    return this
}());

或者像requirejs库中处理的那样：
(function(global) {
    //操作global

}(this))

最好将所有变量用一个var声明在方法一开始的地方，可读的同时，也可以大概知道其声明意义(初始化的前提下)，另外避免随意定义变量，而出现逻辑错误，一定记得js先获取声明再执行，必须下面的反模式例子：
myname = "global"; // global variable
function func() {
    alert(myname); // "undefined"
    var myname = "local";
    alert(myname); // "local"
}
func();
此例子中你可能想着第一个alert是global，但是因为接下来有局部声明(方法内的声明，虽然后来才声明的，这也就是所谓的声明提升)，因此会先读取声明(执行前是undefined)，然后再执行

js中数组最好用for循环，对象最好用for-in循环，需要注意的是for-in循环对象时，最好使用hasOwnProperty方法过滤作用域链上的属性，只取得对象本身的属性，比如：

for(var i in obj) {
    if(obj.hasOwnProperty(i)) {
        console.log(i, ":" , obj(i));
    }
}

当必须使用eval时，可以用new Function代替，因为new Function方法运行在局部作用域中，而eval就不是了。另一个避免eval自动生成全局变量的方式是将eval方法包装在立即执行的方法中

console.log(typeof un); // "undefined"
console.log(typeof deux); // "undefined"
console.log(typeof trois); // "undefined"
var jsstring = "var un = 1; console.log(un);";
eval(jsstring); // logs "1"
jsstring = "var deux = 2; console.log(deux);";
new Function(jsstring)(); // logs "2"
jsstring = "var trois = 3; console.log(trois);";
(function () {
eval(jsstring);
}()); // logs "3"
console.log(typeof un); // "number"
console.log(typeof deux); // "undefined"
console.log(typeof trois); // "undefined"


eval和Function的另一个区别是：eval可以access并且modify其作用域外的作用域变量，但是Function不可以，如下例：
(function () {
    var local = 1;
    eval("local = 3; console.log(local)"); // logs 3
    console.log(local); // logs 3
}());
(function () {
    var local = 1;
    Function("console.log(typeof local);")(); // logs undefined
}());

Using parseInt()you can get a numeric value from a string. The function accepts a second radix parameter, which is often omitted but shouldn’t be. The problems occur when the string to parse starts with 0: for example, a part of a date entered into a form field. Strings that start with 0 are treated as octal numbers (base 8) in ECMAScript 3;
however, this has changed in ES5. To avoid inconsistency and unexpected results, always specify the radix parameter:
var month = "06",
year = "09";
month = parseInt(month, 10);
year = parseInt(year, 10);
In this example, if you omit the radix parameter like  parseInt(year), the returned value will be 0, because “09” assumes octal number (as if you did parseInt(year, 8)) and 09 is not a valid digit in base 8.
Alternative ways to convert a string to a number include:
+"08" // result is 8
Number("08") // 8
These are often faster than  parseInt(), because  parseInt(), as the name suggests, parses and  doesn’t  simply  convert.  But  if  you’re  expecting  input  such  as  “08  hello”, parseInt()will return a number, whereas the others will fail with NaN.


缩进的时候一定将开花括号放在条件的同一行，否则可能出错
//good
function func() {
    return {
        name: "Batman"
    };
}

// bad
function func() {
    return 
    {
        name: "Batman"
    }
}
上面糟糕的书写方式会造成不可预知的错误，因为其等价于：
function func() {
    return "undefined";
    {
        name: "Batman"
    }
}

设计模式：
1. 单例模式：
    单例模式就是每次得到的对象都是同一个对象的引用，有三种方法：全局变量引用；function的静态属性引用；闭包
静态属性引用可能会被更改；全局变量会污染命名空间；最好的闭包，下面分别实现静态属性引用和闭包两种单例模式

全局变量引用：
function Universe() {
    // do we have an existing instance?
    if (typeof Universe.instance === "object") {
        return Universe.instance;
    }
    // proceed as normal
    this.start_time = 0;
    this.bang = "Big";
    // cache
    Universe.instance = this;
    // implicit return:
    // return this;
}
// testing
var uni = new Universe();
var uni2 = new Universe();
uni === uni2; // true

// 闭包：
function Universe() {
    // the cached instance
    var instance = this;
    // proceed as normal
    this.start_time = 0;
    this.bang = "Big";
    // rewrite the constructor
    Universe = function () {
        return instance;
    };
}
// testing
var uni = new Universe();
var uni2 = new Universe();
uni === uni2; // true
// 需要注意的是，经过多方实践，在构造方法中只有返回对象才会覆盖new创建的对象，这也是为什么返回instance或者Universe.instance有效的原因。返回变量根本没用，可以忽略
再次强调一下new的执行过程：

    1、建立一个新对象；
    2、将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象;
    3、将该对象作为this参数调用构造函数，完成成员设置等初始化工作；

闭包方式创建的构造丢失了对最初构造的引用，所有原构造后来添加的原型属性就失去了意义：
// adding to the prototype
Universe.prototype.nothing = true;
var uni = new Universe();
// again adding to the prototype
// after the initial object is created
Universe.prototype.everything = true;
var uni2 = new Universe();
Testing:
// only the original prototype was
// linked to the objects

uni.nothing; // true
uni2.nothing; // true
uni.everything; // undefined
uni2.everything; // undefined
// that sounds right:
uni.constructor.name; // "Universe"
// but that's odd:
uni.constructor === Universe; // false  ----对象的构造是最原始的构造方法，而此时的Universe只是一个实例对象

为了正确引用原有的构造，可以作如下的modify：
function Universe() {
    // the cached instance
    var instance;
    // rewrite the constructor
    Universe = function Universe() {
        return instance;
    };
    // carry over the prototype properties
    Universe.prototype = this;
    // the instance
    instance = new Universe();
    // reset the constructor pointer
    instance.constructor = Universe;
    // all the functionality
    instance.start_time = 0;
    instance.bang = "Big";
    return instance;
}

经过上面的处理，现在所有的测试都会如预期的执行
Now all the test cases should work as expected:
// update prototype and create instance
Universe.prototype.nothing = true; // true
var uni = new Universe();
Universe.prototype.everything = true; // true
var uni2 = new Universe();
// it's the same single instance
uni === uni2; // true
// all prototype properties work
// no matter when they were defined

uni.nothing && uni.everything && uni2.nothing && uni2.everything; // true
// the normal properties work
uni.bang; // "Big"
// the constructor points correctly
uni.constructor === Universe; // true

另一个实现单例模式的方式，立即执行的方式，将单例对象作为包装方法的私有变量
(function () {
    var instance;
    Universe = function Universe() {
        if (instance) {
            return instance;
        }
        instance = this;
        // all the functionality
        this.start_time = 0;
        this.bang = "Big";
    };
}());

2.Factory模式
factory模式的创建是基于以下两个原因：
1. 建立相似的对象时进行重复的操作
2. 为用户提供在编译阶段不用知道特定类名来创建对象的方式
来看一个实例，条件：
* 一个父构造：CarMaker
* 父构造的一个静态方法factory，它用来创建car对象
* 继承自CarMaker的特定构造：CarMaker.Compact,CarMaker.SUV,CarMaker.convertible,他们都作为CarMaker的静态方法存在，使全局命名空间干净清爽，当我们需要他们的时候也知道去哪找
其使用情况如下：
var corolla = CarMaker.factory('Compact');
var solstice = CarMaker.factory('Convertible');
var cherokee = CarMaker.factory('SUV');
corolla.drive(); // "Vroom, I have 4 doors"
solstice.drive(); // "Vroom, I have 2 doors"
cherokee.drive(); // "Vroom, I have 17 doors"

其中CarMaker.factory("Compact");的factory方法在运行时接收一个类型参数来创建返回相应类型的对象。没用new或者任何对象迭代来得到自己想要的对象
下面是其实现方式：
// parent constructor
function CarMaker() {}
// a method of the parent
CarMaker.prototype.drive = function () {
    return "Vroom, I have " + this.doors + " doors";
};
// the static factory method
CarMaker.factory = function (type) {
    var constr = type,
        newcar;
    // error if the constructor doesn't exist
    if (typeof CarMaker[constr] !== "function") {
        throw {
            name: "Error",
            message: constr + " doesn't exist"
        };
    }
    // at this point the constructor is known to exist
    // let's have it inherit the parent but only once
    if (typeof CarMaker[constr].prototype.drive !== "function") {
        CarMaker[constr].prototype = new CarMaker(); // 避免了构造函数的重复继承
    }
    // create a new instance
    newcar = new CarMaker[constr]();
    // optionally call some methods and then return...
    return newcar;
};
// define specific car makers
CarMaker.Compact = function () {
    this.doors = 4;
};
CarMaker.Convertible = function () {
    this.doors = 2;
};
CarMaker.SUV = function () {
    this.doors = 24;
};

其实Object是个内建的factory方法，它会根据传入其中的参数类型，生成不同的类型对象，而且它可用new也可不用，请看实例：
var o = new Object(),
n = new Object(1),
s = Object('1'),
b = Object(true);
// test
o.constructor === Object; // true
n.constructor === Number; // true
s.constructor === String; // true
b.constructor === Boolean; // true
它作为factory可能用处不大，但是可以说明factory无处不在

3. 迭代模式：
迭代模式中，你需要一个对象包含一些类型的数据，它们的结构复杂，你只需要提供简单的方法获取那些数据，你的对象需要一个next方法，调用next返回想要的数据元素。当然next的意义由你自己定义

你可能会这样调用使用：
var element;
while (element = agg.next()) {
    // do something with the element ...
    console.log(element);
}
你的对象也可能需要个hasNext方法使用户知道其已经到了数据的结尾
while (agg.hasNext()) {
    // do something with the next element...
    console.log(agg.next());
}
下面是它的简单实现：
var agg = (function () {
    var index = 0,
    data = [1, 2, 3, 4, 5],
    length = data.length;
    return {
        next: function () {
            var element;
            if (!this.hasNext()) {
                return null;
            }
            element = data[index];
            index = index + 2;
            return element;
        },
        hasNext: function () {
            return index < length;
        },
        rewind: function () { // 回归到最开始的元素
            index = 0;
        },
        current: function () { // 返回当前的元素
            return data[index];
        }
    };
}());

4.装饰者模式
装饰者模式中，可以动态的为对象添加附加功能

装饰者模式的一个明了的特征是可以自定义和配置预期的行为：你先创建了一个plain对象，它具有一些基本的功能，然后你想要选择一些装饰来增强你的plain对象，如果需要顺序的话，可以按顺序增加装饰功能

比如你在实现一个卖东西的web应用。每个卖品是一个新的sale对象，这个sale对象konws物品的price，可以通过sale.getPrice()方法返回。想象你的客户在加拿大的魁北克省。这种情况下，买家需要支付联邦税和魁北克省税。你可能就需要为你的对象decorate联邦税和魁北克税的功能，它的简单调用可能如下：
var sale = new Sale(100); // the price is 100 dollars
sale = sale.decorate('fedtax'); // add federal tax
sale = sale.decorate('quebec'); // add provincial tax
sale = sale.decorate('money'); // format like money
sale.getPrice(); // "$112.88"
另种情况下，你的买家可能再一个不需要省税的省，你可能需要使用加拿大dollars转化price，可能需要向下面这样调用：
var sale = new Sale(100); // the price is 100 dollars
sale = sale.decorate('fedtax'); // add federal tax
sale = sale.decorate('cdn'); // format using CDN
sale.getPrice();
可以看到，这种方式可以灵活的在运行时为对象添加功能，那么它的实现怎样呢，下面给个简单的例子；
function Sale(price) {
    this.price = price || 100;
}
Sale.prototype.getPrice = function () {
    return this.price;
};
Sale.decorators = {};

Sale.decorators.fedtax = {
    getPrice: function () {
        var price = this.uber.getPrice();
        price += price * 5 / 100;
        return price;
    }
};
Sale.decorators.quebec = {
    getPrice: function () {
        var price = this.uber.getPrice();
        price += price * 7.5 / 100;
        return price;
    }
};
Sale.decorators.money = {
    getPrice: function () {
        return "$" + this.uber.getPrice().toFixed(2);
    }
};
Sale.decorators.cdn = {
    getPrice: function () {
        return "CDN$ " + this.uber.getPrice().toFixed(2);
    }
};
Sale.prototype.decorate = function (decorator) {
    var F = function () {},
    overrides = this.constructor.decorators[decorator], // this.constructor 始终指向Sale(price)构造
    i, newobj;
    F.prototype = this;  // prototype = this是关键
    newobj = new F();
    newobj.uber = F.prototype;
    for (i in overrides) {
        if (overrides.hasOwnProperty(i)) {
            newobj[i] = overrides[i];
        }
    }
    return newobj;
};

var sale = new Sale(100); // the price is 100 dollars
sale = sale.decorate('fedtax'); // add federal tax
sale = sale.decorate('quebec'); // add provincial tax
sale = sale.decorate('money'); // format like money
sale.getPrice(); // "$112.88"
上面的decorate方法生成的对象中getPrice需要向上调用每一级父元素中的此方法，直到获取到最根部的price

上述的实现使用了js的继承的特点，接下来实现一个不太一样的方案，此方案完全不用继承父类，但是完全得益于js的动态性
其调用方式如下：
var sale = new Sale(100); // the price is 100 dollars
sale.decorate('fedtax'); // add federal tax
sale.decorate('quebec'); // add provincial tax
sale.decorate('money'); // format like money
sale.getPrice(); // "$112.88"

实现方式如下：其中getPrice方法变得更加简单，因为他们不再需要调用父getPrice方法获得中间结果。相反这些结果通过参数传递
function Sale(price) {
    this.price = (price > 0) || 100;
    this.decorators_list = [];
}

Sale.decorators = {};
Sale.decorators.fedtax = {
    getPrice: function (price) {
        return price + price * 5 / 100;
    }
};
Sale.decorators.quebec = {
    getPrice: function (price) {
        return price + price * 7.5 / 100;
    }
};
Sale.decorators.money = {
    getPrice: function (price) {
        return "$" + price.toFixed(2);
    }
};
上个方案中decorate比较复杂，getPrice比较简单，此方案中decorate比较简单，getPrice比较复杂，实现所有功能

Sale.prototype.decorate = function (decorator) {
    this.decorators_list.push(decorator);
};
Sale.prototype.getPrice = function () {
    var price = this.price,
        i,
        max = this.decorators_list.length,
        name;
    for (i = 0; i < max; i += 1) {
        name = this.decorators_list[i];
        price = Sale.decorators[name].getPrice(price);
    }
    return price;
};

相比来说，此实现方案更简单些，getPrice是唯一允许装饰的方法，此方案可以抽象出一个helper

5.策略模式（Strategy）:
策略模式允许在运行时选择算法。客户端的代码可以使用同一个接口，由此接口从一系列可能的算法中选择一个来根据将要处理的上下文处理指定任务

使用策略模式的一个例子是解决表单验证的问题。你可以创建一个拥有validata方法的验证对象。不论表单类型是什么调用此方法总是会返回同样的处理数据---不符合验证规则的数据或者错误消息

举例如下：
假如有以下数据需要验证，它们是来自页面上的某个表单：
var data = {
    first_name: "Super",
    last_name: "Man",
    age: "unknown",
    username: "o_0"
}  
为了使验证器知道哪个验证策略是最合适的，你需要首先配置验证器，设置你认为valid和acceptable的验证规则

比如你不需要last name，但是接受任意的first name，需要age是一个number，username只包含字母和数字，不包含特殊符号。配置信息可能如下所示：
validator.config = {
    first_name: "isNonEmpty",
    age: "isNumber",
    username: "isAlphaNum"
}

然后像下面这样调用执行你的validate方法进行验证
validator.validate(data);
if (validator.hasErrors()) {
    console.log(validator.messages.join("\n"));
}
它可能会print如下的error message：
Invalid value for *age*, the value can only be a valid number, e.g. 1, 3.14 or 2010
Invalid value for *username*, the value can only contain characters and numbers, no special
symbols

请看针对上述的简单实现：
// checks for non-empty values
validator.types.isNonEmpty = {
    validate: function (value) {
        return value !== "";
    },
    instructions: "the value cannot be empty"
};
// checks if a value is a number
validator.types.isNumber = {
    validate: function (value) {
        return !isNaN(value);
    },
    instructions: "the value can only be a valid number, e.g. 1, 3.14 or 2010"
};
// checks if the value contains only letters and numbers
validator.types.isAlphaNum = {
    validate: function (value) {
        return !/[^a-z0-9]/i.test(value);
    },
    instructions: "the value can only contain characters and numbers, no special symbols"
};
var validator = {
    // 所有验证规则处理类集合
    types: {},
    // 验证类型对应的错误消息
    messages: [],
    // 配置验证类型的地方
    config: {},
    // 唯一暴露的public API，用来处理验证，参数是key->value的验证对象
    validate: function (data) {
        var i, msg, type, checker, result_ok;
        // 清空所有验证消息
        this.messages = [];
        for (i in data) {
            if (data.hasOwnProperty(i)) {
                type = this.config[i];
                checker = this.types[type]; // 获取验证规则的验证类
                if (!type) {
                    continue; // 验证规则不存在不处理
                }
                if (!checker) { // 验证器不存在抛出错误
                throw {
                    name: "ValidationError",
                    message: "No handler to validate type " + type
                };
            }
            // 使用对应验证器验证数据元素是否符合要求
            result_ok = checker.validate(data[i]);
            if (!result_ok) {
                msg = "Invalid value for *" + i + "*, " + checker.instructions;
                this.messages.push(msg);
            }
        }
        return this.hasErrors();
    },
    // helper
    hasErrors: function () {
        return this.messages.length !== 0;
    }  
};

如你所见，validator对象是通用的，可以用于所有的验证规则。改进它的方式可能就是添加更多的验证类型。所有要做的是配置验证规则，然后运行validate方法

6.外观模式（Facade）：
外观模式提供了一个对象的可选的接口，可以通过一个简单接口封装一些复杂的操作，比如调用了两个不同的方法的操作等，拿事件对象的preventDefault和stopProprogation方法来说，经常需要同时调用此两个方法阻止事件冒泡和触发默认事件

var myevent = {
    // ...
    stop: function (e) {
        e.preventDefault();
        e.stopPropagation();
    }
    // ...
};
外观模式也适合用来隐藏浏览器间脚本兼容的细节， 比如：

var myevent = {
    // ...
    stop: function (e) {
        // others
        if (typeof e.preventDefault === "function") {
            e.preventDefault();
        }
        if (typeof e.stopPropagation === "function") {
            e.stopPropagation();
        }
        // IE
        if (typeof e.returnValue === "boolean") {
            e.returnValue = false;
        }
        if (typeof e.cancelBubble === "boolean") {
            e.cancelBubble = true;
        }
    }
    // ...
};
外观模式在重新设计和重构的时候非常有用，当你想用一个不同的实现来代替一个object时，有可能新的代码正在使用这个object，这个时候就需要为此object创建一个外观来调用它

7. 代理模式：
代理模式中，一个对象作为另一个对象的接口，不同于外观模式的将不同的方法combine组成个简单的方法，代理模式可以保护对象的访问权限
一个简单的应用实例可能就是lazy initialization.假设初始化真正的对象代价昂贵，而且客户端进行初始化之后却没有使用。这种情况下代理可以作为真实对象的接口，接受初始化请求却不传递给真实对象，直到真实对象的确被使用到web应用中，最昂贵的操作之一是http请求，接下来以此作为实例说明代理模式

假设页面中有一系列video title，当点击它时，会出现关于此video的更多信息，也可以播放video，那我们就是要在video和http间设置代理，video具有getInfo和getPlayer方法，http用来加载video，具有http.makerequest方法

没有代理的情况下videos.getInfo将会调用http.makeRequest方法，先来看看没有代理的情况下的实现方式：
<p><span id="toggle-all">Toggle Checked</span></p>
<ol id="vids">
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--2158073">Gravedigger</a></li>
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--4472739">Save Me</a></li>
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--45286339">Crush</a></li>
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--2144530">Don't Drink The Water</a></li>
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--217241800">Funny the Way It Is</a></li>
    <li><input type="checkbox" checked><a
    href="http://new.music.yahoo.com/videos/--2144532">What Would You Say</a></li>
</ol>

var $ = function (id) {
    return document.getElementById(id);
};
$('vids').onclick = function (e) {
    var src, id;
        e = e || window.event;
    src = e.target || e.srcElement;
    if (src.nodeName !== "A") {
        return;
    }
    if (typeof e.preventDefault === "function") {
        e.preventDefault();
    }
    e.returnValue = false;
    id = src.href.split('--')[1];
    if (src.className === "play") {
        src.parentNode.innerHTML = videos.getPlayer(id);
        return;
    }
    src.parentNode.id = "v" + id;
    videos.getInfo(id);
};


$('toggle-all').onclick = function (e) {
    var hrefs,
        i,
        max,
        id;
    hrefs = $('vids').getElementsByTagName('a');
    for (i = 0, max = hrefs.length; i < max; i += 1) {
        // skip play links
        if (hrefs[i].className === "play") {
            continue;
        }
        // skip unchecked
        if (!hrefs[i].parentNode.firstChild.checked) {
            continue;
        }
        id = hrefs[i].href.split('--')[1];
        hrefs[i].parentNode.id = "v" + id;
        videos.getInfo(id);
    }
};
var videos = {
    getPlayer: function (id) {...},
    updateList: function (data) {...},
    getInfo: function (id) {
        var info = $('info' + id);
        if (!info) {
            http.makeRequest([id], "videos.updateList");
            return;
        }
        if (info.style.display === "none") {
            info.style.display = '';
        } else {
            info.style.display = 'none';
        }
    }
};
var http = {
    makeRequest: function (ids, callback) {
        var url = 'http://query.yahooapis.com/v1/public/yql?q=',
        sql = 'select * from music.video.id where ids IN ("%ID%")',
        format = "format=json",
        handler = "callback=" + callback,
        script = document.createElement('script');
        sql = sql.replace('%ID%', ids.join('","'));
        sql = encodeURIComponent(sql);
        url += sql + '&' + format + '&' + handler;
        script.src = url;
        document.body.appendChild(script);
    }
};

使用代理我们可以进行更好的改进，我们在videos和http的调用之间停留50ms，如果50ms内有对代理的对象的多次操作那么就combine这多次操作为一次操作请求发送给代理的真实对象。实现方式：

var proxy = {
    ids: [],
    delay: 50,
    timeout: null,
    callback: null,
    context: null,
    makeRequest: function (id, callback, context) {
        // add to the queue
        this.ids.push(id);
        this.callback = callback;
        this.context = context;
        // set up timeout
        if (!this.timeout) {
            this.timeout = setTimeout(function () {
                proxy.flush();
            }, this.delay);
        }
    },
    flush: function () {
        http.makeRequest(this.ids, "proxy.handler");
        // clear timeout and queue
        this.timeout = null;
        this.ids = [];
    },
    handler: function (data) {
        var i, max;
        // single video
        if (parseInt(data.query.count, 10) === 1) {
            proxy.callback.call(proxy.context, data.query.results.Video);
            return;
        }
        // multiple videos
        for (i = 0, max = data.query.results.Video.length; i < max; i += 1) {
            proxy.callback.call(proxy.context, data.query.results.Video[i]);
        }
    }
};


通过引进代理模式对初始代码的改进使得多个web请求合并到同一个请求中
代理模式也可以充当缓存的角色，将第一次请求的数据进行缓存，如果再次调用同样的数据信息就可以从代理缓存中直接获取，而不用通过http网络

9.中间者模式：Mediator
中间者模式可以使不同的对象进行通信。随着应用程序的扩增，你会添加非常多的object，当重构的时候很多对象可能会被removed或者rearraged。如果对象间彼此依赖的太多，或者直接通信将会造成严重的紧耦合问题。很难只改变一方而不用改变另一方。中间者模式可以促进松耦合，确保可维护性。此模式下，各个对象不直接通信，而是通过一个中间人。当某个对象改变了其state，通知mediator，然后mediator将此改变通知给所有需要知道其状态改变的对象

我们来看一个使用mediator模式的实例。场景如下：两个玩家在一分半的时间里比赛按下按钮的次数。玩家一按1按钮，玩家二按0按钮。记分板及时更新成绩。
则涉及的对象是Player1 、Player2、ScoreBoard、Mediator

其中mediator知道所有其他的对象。它与键盘设备(input)通信，处理keypress事件，决定哪个玩家按了按钮并将之记录下来。除了mediator，其他对象之间互不相识，这使得更新游戏变得很简单，比如添加新的玩家，或者增加另一个显示剩余时间的对象
function Player(name) {
    this.points = 0;
    this.name = name;
}
Player.prototype.play = function () {
    this.points += 1;
    mediator.played();
};
var scoreboard = {
    // HTML element to be updated
    element: document.getElementById('results'),
    // update the score display
    update: function (score) {
        var i, msg = '';
        for (i in score) {
            if (score.hasOwnProperty(i)) {
                msg += '<p><strong>' + i + '<\/strong>: ';
                msg += score[i];
                msg += '<\/p>';
            }
        }
        this.element.innerHTML = msg;
    }
};


var mediator = {
    // all the players
    players: {},
    // initialization
    setup: function () {
        var players = this.players;
        players.home = new Player('Home');
        players.guest = new Player('Guest');
    },
    // someone plays, update the score
    played: function () {
        var players = this.players,
        score = {
            Home: players.home.points,
            Guest: players.guest.points
        };
        scoreboard.update(score);
    },

    // handle user interactions
    keypress: function (e) {
        e = e || window.event; // IE
        if (e.which === 49) { // key "1"
            mediator.players.home.play();
            return;
        }
        if (e.which === 48) { // key "0"
            mediator.players.guest.play();
            return;
        }
    }
};

mediator.setup();
window.onkeypress = mediator.keypress;
// game over in 30 seconds
setTimeout(function () {
    window.onkeypress = null;
    alert('Game over!');
}, 30000);

*****************************************************************

观察者模式：
观察者模式主要用来进行解耦，浏览器端的事件监听就是一种典型的观察者模式。接下来看一个具体的实例。
场景：有一个发布者Paper，它发布每日新闻(daily newspaper)和月季杂志(monthly magazine)，当其发布信息时，订阅者joe会得到通知。
Paper对象需要一个数组subscribers属性来存储所有的订阅者。Paper也可以提供unsubscribe方法取消订阅。也就是说发布者需要这些成员属性：
subscribers: []
subscribe: function
unsubscribe:function
publish:function
上面的三个方法都需要一个type参数，因为发布者可能会发布几个消息事件(newspaper或者magazine)，相应的订阅者可以选择性的订阅需要的事件。先看一个简单的实现实例：

var publisher = {
    subscribers: {
        any: [] // event type: subscribers
    },
    subscribe: function (fn, type) {
        type = type || 'any';
        if (typeof this.subscribers[type] === "undefined") {
            this.subscribers[type] = [];
        }
        this.subscribers[type].push(fn);
    },
    unsubscribe: function (fn, type) {
        this.visitSubscribers('unsubscribe', fn, type);
    },
    publish: function (publication, type) {
        this.visitSubscribers('publish', publication, type);
    },
    visitSubscribers: function (action, arg, type) {
        var pubtype = type || 'any',
            subscribers = this.subscribers[pubtype],
            i,
            max = subscribers.length;

        for (i = 0; i < max; i += 1) {

            if (action === 'publish') {
                subscribers[i](arg);
            } else {
                if (subscribers[i] === arg) {
                    subscribers.splice(i, 1);
                }
            }
        }
    }
};

function makePublisher(o) {
    var i;
    for (i in publisher) {
        if (publisher.hasOwnProperty(i) && typeof publisher[i] === "function") {
            o[i] = publisher[i];
        }
    }
    o.subscribers = {any: []};
}

var paper = {
    daily: function () {
        this.publish("big news today");
    },
    monthly: function () {
        this.publish("interesting analysis", "monthly");
    }
};

makePublisher(paper);

var joe = {
    drinkCoffee: function (paper) {
        console.log('Just read ' + paper);
    },
    sundayPreNap: function (monthly) {
        console.log('About to fall asleep reading this ' + monthly);
    }
};

paper.subscribe(joe.drinkCoffee);
paper.subscribe(joe.sundayPreNap, 'monthly');


paper.daily();
paper.daily();
paper.monthly();
执行结果是：
Just read big news today
Just read big news today
About to fall asleep reading this interesting analysis

接下来让joe也成为publisher，可以发布blog或者micro blog

makePublisher(joe);
joe.tweet = function (msg) {
    this.publish(msg);
};

paper想要订阅其订阅者的blog，为其自身添加readTweets方法
paper.readTweets = function (tweet) {
    alert('Call big meeting! Someone ' + tweet);
};
joe.subscribe(paper.readTweets);

joe.tweet("hated the paper today");
发布结果是：
“Call big meeting! Someone hated the paper today.”

接下来用观察者模式实现中介者模式中的game
var publisher = {
    subscribers: {
        any: []
    },
    on: function (type, fn, context) {
        type = type || 'any';
        fn = typeof fn === "function" ? fn : context[fn];
        if (typeof this.subscribers[type] === "undefined") {
            this.subscribers[type] = [];
        }
        this.subscribers[type].push({fn: fn, context: context || this});
    },
    remove: function (type, fn, context) {
        this.visitSubscribers('unsubscribe', type, fn, context);
    },
    fire: function (type, publication) {
        this.visitSubscribers('publish', type, publication);
    },
    visitSubscribers: function (action, type, arg, context) {
        var pubtype = type || 'any',
            subscribers = this.subscribers[pubtype],
            i,
            max = subscribers ? subscribers.length : 0;
        for (i = 0; i < max; i += 1) {
            if (action === 'publish') {
                subscribers[i].fn.call(subscribers[i].context, arg);
            } else { // unsubscribe
                if (subscribers[i].fn === arg && subscribers[i].context === context) {
                    subscribers.splice(i, 1);
                }
            }
        }
    }
};

function Player(name, key) {
    this.points = 0;
    this.name = name;
    this.key = key;
    this.fire('newplayer', this);
}
Player.prototype.play = function () {
    this.points += 1;
    this.fire('play', this);
};

/*
    The new  parts here are that the constructor accepts  key, the keyboard key that the player presses to make points. (The keys were hardcoded before.) Also, every time a new player object is created, an event “newplayer” is fired. Similarly, every time a player plays, the event “play” is fired.
    The scoreboardobject remains the same; it simply updates the display with the current score.
    The new gameobject can keep track of all players, so it can produce a score and fire a “scorechange” event. It will also subscribe to all “keypress” events from the browser and will know about the keys that correspond to each player:
*/


var game = {
    keys: {},
    addPlayer: function (player) {
        var key = player.key.toString().charCodeAt(0);
        this.keys[key] = player;
    },
    handleKeypress: function (e) {
        e = e || window.event; // IE
        if (game.keys[e.which]) {
            game.keys[e.which].play();
        }
    },
    handlePlay: function (player) {
        var i,
            players = this.keys,
            score = {};
        for (i in players) {
            if (players.hasOwnProperty(i)) {
                score[players[i].name] = players[i].points;
            }
        }
        this.fire('scorechange', score);
    }
};

makePublisher(Player.prototype);
makePublisher(game);

Player.prototype.on("newplayer", "addPlayer", game);
Player.prototype.on("play", "handlePlay", game);
game.on("scorechange", scoreboard.update, scoreboard);
window.onkeypress = game.handleKeypress;

var playername, key;
while (1) {
    playername = prompt("Add player (name)");
    if (!playername) {
        break;
    }
    while (1) {
        key = prompt("Key for " + playername + "?");
        if (key) {
            break;
        }
    }
    new Player(playername, key);
}

通过对中间这模式的改进可以看出：观察者模式使得on(订阅)和fire(发布)不再集中，这些操作可能发生在程序中的任何地方，从而变的不容易调试


******************************************************
设计模式小结：
Singleton：Creating only one object of a “class.” 
Factory：A method that creates objects of type specified as a string at runtime.
Iterator：Providing  an  API  to  loop  over  and  navigate  around  a  complex  custom  data structure.
Decorator：Tweaking objects at runtime by adding functionality from predefined decorator objects.
Strategy：Keeping the same interface while selecting the best strategy to handle the specific task (context).
Façade：Providing  a  more  convenient  API  by  wrapping  common  (or  poorly  designed) methods into a new one.
Proxy：Wrapping an object to control the access to it, with the goal of avoiding expensive operations by either grouping them together or performing them only when really necessary.

Mediator：Promoting loose coupling by having your objects not “talk” to each other directly but only though a mediator object.
Observer：Loose coupling by creating “observable” objects that notify all their observers when an interesting event occurs (also called subscriber/publisher or “custom events”).


DOM和浏览器模式：
最好使用方法或者属性的能力检测。而不是浏览器的用户代理来做检测决定要使用的脚本
只有在能力检测不能达到目的时才使用代理做检测。比如：
// antipattern
if (navigator.userAgent.indexOf('MSIE') !== −1) {
    document.attachEvent('onclick', console.log);
}
// better
if (document.attachEvent) {
    document.attachEvent('onclick', console.log);
}
// or even more specific
if (typeof document.attachEvent !== "undefined") {
    document.attachEvent('onclick', console.log);
}


// antipattern
var padding = document.getElementById("result").style.padding,
margin = document.getElementById("result").style.margin;

// better
var style = document.getElementById("result").style,
padding = style.padding,
margin = style.margin;

// Using selector APIs means using the methods:
document.querySelector("ul .selected");
document.querySelectorAll("#widget .class");

在操作DOM树时在需要的时候多使用选择器API，比如上面的querySelector
关于Selector API的说明：
These methods accept a CSS selector string and return a list of DOM nodes that match the selection. The selector methods are available in modern browsers (and in IE since version 8) and will always be faster than if you do the selection yourself using other DOM methods. 

添加大量DOM元素时使用document.createDocumentFragment方法，更新DOM树时可以使用clone，在clone上操作之后再替代原始元素节点：
var oldnode = document.getElementById('result'),
clone = oldnode.cloneNode(true);
// work with the clone...
// when you're done:
oldnode.parentNode.replaceChild(clone, oldnode)

使用JSONP实现跨域的无刷新加载数据实例：
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>ttt</title>
    <style>
        td {width: 50px; height: 50px; font-size: 50px; font-family: monospace; border: 1px solid lightGrey; text-align: center; color: red;}
        .server {color: blue;}
        body {font-family: Helvetica;}
    </style>
</head>
<body>

    <h1>Tic-tac-toe: <br>server "X" vs. client "O"</h1>
    
    <button id="new">New game</button>
    <button id="server">Server play</button>
    
    <table>
        <tr>
            <td id="cell-1">&nbsp;</td>
            <td id="cell-2">&nbsp;</td>
            <td id="cell-3">&nbsp;</td>
        </tr>
        <tr>
            <td id="cell-4">&nbsp;</td>
            <td id="cell-5">&nbsp;</td>
            <td id="cell-6">&nbsp;</td>            
        </tr>
        <tr>
            <td id="cell-7">&nbsp;</td>
            <td id="cell-8">&nbsp;</td>
            <td id="cell-9">&nbsp;</td>
        </tr>
        
    </table>


<script>

var ttt = {
    // cells played so far
    played: [], 
    
    // shorthand
    get: function (id) { 
        return document.getElementById(id);
    },
    
    // handle clicks
    setup: function () {
        this.get('new').onclick = this.newGame;
        this.get('server').onclick = this.remoteRequest;
    },
    
    // clean the board
    newGame: function () {
        var tds = document.getElementsByTagName("td"),
            max = tds.length,
            i;
        for (i = 0; i < max; i += 1) {
            tds[i].innerHTML = "&nbsp;";
        }
        ttt.played = [];        
    },
    
    // make a request
    remoteRequest: function () {
        var script = document.createElement("script");
        script.src = "server.php?callback=ttt.serverPlay&played=" + ttt.played.join(',');
        document.body.appendChild(script);
    },
    
    // 因为动态加载的js会在加载完成之后立即执行脚本，所以会立即执行serverPlay callback
    // callback, server's turn to play
    serverPlay: function (data) {
        if (data.error) {
            alert(data.error);
            return;
        }
        data = parseInt(data, 10);
        this.played.push(data);

        this.get('cell-' + data).innerHTML = '<span class="server">X<\/span>';

        setTimeout(function () {
            ttt.clientPlay();
        }, 300); // as if thinking hard

    },
    
    // client's turn to play
    clientPlay: function () {
        var data = 5;

        if (this.played.length === 9) {
            alert("Game over");
            return;
        }
        
        // keep coming up with random numbers 1-9 
        // until one not taken cell is found
        while (this.get('cell-' + data).innerHTML !== "&nbsp;") {
            data = Math.ceil(Math.random() * 9);
        }
        this.get('cell-' + data).innerHTML = 'O';
        this.played.push(data);
        
    }
    
};

ttt.setup();

</script>

</body>
</html>

使用缓存提升用户体验也很必要，通常可以将过期头设置的时间长一些，这个可以在服务器做配置，比如在.htaccess中设置：
ExpiresActive On
ExpiresByType application/x-javascript "access plus 10 years"

使用CDN可以提升用户体验，没有那个能力也可以使用Google的开源库，从而受益于CDN

CDN stands for Content Delivery Network. This is a paid (sometimes quite pricey) hosting service that lets you distribute copies of your files in different data centers around the world and have them served quicker to your users, while still keeping the same URL in your code.

Even if you don’t have a budget for CDN, you can still benefit from some free options:
• Google hosts a number of popular open-source libraries, which you can link to for
free and benefit from its CDN.
• Microsoft hosts jQuery and its own Ajax libraries.
• Yahoo! hosts YUI library on its CDN.


预加载可以提前加载接下来的page可能会需要你的js，但是你可能不希望其加载完成之后执行，因为执行可能会出错，这样就可以使用两种方式：
IE下：new Image().src = "preloadme.js";
在其他的浏览器下可以使用<object>元素
var obj = document.createElement('object');
obj.data = "preloadme.js";
document.body.appendChild(obj);
为了避免object元素显示，你需要设置器width和height为0，具体通用实例如下：
var preload;

if (/*@cc_on!@*/false) { // IE sniffing with conditional comments
    preload = function (file) {
        new Image().src = file;
    };
} else {
    preload = function (file) {
        var obj = document.createElement('object'),
        body = document.body;

        obj.width = 0;
        obj.height = 0;
        obj.data = file;
        body.appendChild(obj);
    };
}

preload('my_web_worker.js');
预加载可以用于任何类型的文件，不限于js





1. Constructor`s Return Values:
当通过new操作构造函数时，构造函数方法通常返回一个object，默认情况下，此object是由this引用的对象，如果构造方法内部没有为this添加任何属性，那么就会返回一个empty object，也就是字面量：{} -----非真的是空的，因为它有从Object继承来的prototype属性

构造函数隐式的返回this，即使在构造方法中没有一个return ...；但是你可以return 任何一个你想要return的object。比如：
var Objectmaker = function () {
    // this `name` property will be ignored
    // because the constructor
    // decides to return another object instead
    this.name = "This is it";
    // creating and returning a new object
    var that = {};
    that.name = "And that's that";
    return that;
};
// test
var o = new Objectmaker();
console.log(o.name); // "And that's that"

可见，你可以在你的构造方法中返回任意的object，注意是任意的object，如果返回其他非object(像string或者boolean false)的值虽然不会产生错误，但是会被忽略，取而代之的是由this引用的对象会被返回。
function Waffle() {
    var that = {};
    that.tastes = "yummy";
    return that;
}

function Waffle() {
    return {
        tastes: "yummy"
        };
}
此两种方式都可以通过new和非new的方式访问，返回的结果相同

不过需要注意的是返回非this引用的对象，其constructor属性值就不再是构造方法本身了，也就是丢失了对构造方法prototype的引用。就像上面的Waffle构造中，你向Waffle()的prototype添加的任何属性将不可以被new的对象访问访问

为了避免不适用new时，污染全局空间(this指向全局对象)，可以使用如下方法进行改进，不过如果构造中有对象返回丢失prototype的引用缺陷依然存在
function Waffle() {
    if (!(this instanceof Waffle)) {
        return new Waffle();
    }
    this.tastes = "yummy";
}
Waffle.prototype.wantAnother = true;
// testing invocations
var first = new Waffle(),
second = Waffle();
console.log(first.tastes); // "yummy"
console.log(second.tastes); // "yummy"
console.log(first.wantAnother); // true
console.log(second.wantAnother); // true

2.在检查对象是否是数组的时候常常会出问题：
console.log(typeof [1,2]); // "object"

instanceof Array的模式在IE的跨frame中会出错，使用Array的特征(length、slice、join)检测也会出错，因为没有规定其他的对象就不可以具有这些特性方法

ECMA5定义了新的方法Array.isArray来判断一个对象是否是数组，比如：
Array.isArray([]); // true
// trying to fool the check
// with an array-like object
Array.isArray({
    length: 1,
    "0": 1,
    slice: function () {}
}); // false


可以通过Object.prototype.toString.call(obj)的方式来判断是否是数组，因此可以这么做：
if (typeof Array.isArray === "undefined") {
    Array.isArray = function (arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
    };
}



3.JSON作为一种转换格式，非常轻便和方便的work with许多语言，尤其在js中
唯一要说明的是对JSON字符串的解析，在JSON.parse不支持的情况下，使用eval('('+jstr+')')来解析json字符串


4.先来对比一下正则表达式的两种定义方式：
// regular expression literal
var re = /\\/gm;
// constructor
var re = new RegExp("\\\\", "gm"); 

可见最好还是使用字面量正则表达式比较好，易懂易读，那么什么情况下使用new RegExp的？
只有当pattern事先不确定但是在运行时可以确定的情况下

另一个字面正则和构造函数方式定义的正则的区别在于：字面正则只在解析阶段创建一次对象，如果在一个循环中创建同样的构造正则表达式，之前创造的对象将被返回，其第一次的所有属性都将被设置(such as lastIndex).看下如下实例：
function getRE() {
    var re = /[a-z]/;
        re.foo = "bar";
    return re;
}
var reg = getRE(),
    re2 = getRE();
console.log(reg === re2); // true
reg.foo = "baz";
console.log(re2.foo); // "baz"

上述表现是一些旧的浏览器会出现的情况，此behavior在ES5中已经得到了修正，每次都创建新的object。所以要区别对待，还是要实践


同时需要注意的是，调用RegExp时，使用new与不使用new的表现结果一致；
var reg1 = new RegExp("[a-z]","mg");
var reg2 = RegExp("[a-z]","mg");
var str1 = "fdfd213fdsfs";
var str2 = "fasftfre5343dfds";
console.log(str1.replace(reg1,""));  // 213
console.log(str2.replace(reg2, ""));  //5343


6.弄清基本类型值和对象值，基本类型值有五种：nnumber、string、bollean、null、和undefined，看看其对比：
// a primitive number
var n = 100;
console.log(typeof n); // "number"
// a Number object
var nobj = new Number(100);
console.log(typeof nobj); // "object"

使用基本类型(string、number、bollean)的包装类型来创建的一个原因可能是当你需要为其添加值并且使状态保持一致的时候，因为基本类型不是对象，因此不能为其添加属性，但是基本类型的包装对象是对象呀

// primitive string
var greet = "Hello there";
// primitive is converted to an object
// in order to use the split() method
greet.split(' ')[0]; // "Hello"
// attemting to augment a primitive is not an error
greet.smile = true;
// but it doesn't actually work
typeof greet.smile; // "undefined"

当使用new String时，上面的smile就不会是undefined，但是为string、number、boolean这三种基本类型添加属性的情况并不多用，你一般不需要用到此wrapper constructor

当不使用new时，构造方法将传递给它的参数转换成基本类型值
typeof Number(1); // "number"
typeof Number("1"); // "number"
typeof Number(new Number()); // "number"
typeof String(1); // "string"
typeof Boolean(1); // "boolean"


7.js中有很多内建的错误构造方法，比如：Error(),SyntaxError()，TypeError()等，这些error对象有以下属性：name：错误类型的名称；message：创建此错误对象时传递给它的字符串参数。error对象还有很多其他的比如line number或者错误发生的文件名等错误信息，但是这些额外信息是浏览器的扩展，各个浏览器的实现不一定一致 

另外，throw可以工作在任何对象下，而不用必须是某个error构造方法下，因此你可以throw你自己的对象。这些对象可以有name和message属性，或者其他你想要被catch处理的信息。可以发挥想象充分利用此特性，比如使用它们restore应用程序状态

try {
    // something bad happened, throw an error
    throw {
        name: "MyErrorType", // custom error type
        message: "oops",
        extra: "This was rather embarrassing",
        remedy: genericErrorHandler // who should handle it
    };
} catch (e) {
    // inform the user
    alert(e.message); // "oops"
    // gracefully handle the error
    e.remedy(); // calls genericErrorHandler()
}

不推荐的方式：throw new Error("uh-oh"); 
相对其比较好的方式：
throw {
    name: "Error",
    message: "uh-oh"
};
... or
throw Error("uh-oh");

8. var add = new Function('a', 'b', 'return a + b'); // 定义方式：参数一、参数二、函数体

关于function的几个术语，先对比下面两个方法表达式：
// named function expression
var add = function add(a, b) {
    return a + b;
};

// function expression, a.k.a. anonymous function
var add = function (a, b) {
    return a + b;
};

可以看到你是named function，一个是匿名function，这其中的不同体现在匿名function的name属性为空，虽然name属性不是ECMA标准的一部分，只是这个语言的一种扩展，但是在很多环境中广泛的应用。name属性在使用debugers比如firebug时很有用。
最后的术语是函数声明：
function foo() {
    //function body goes here
}

从语法上看，named function expression和function declarations(方法声明)很相似，尤其你不把方法表达式赋值给一个变量时。有时很难区别function declaration和named function expression之间的不同，除非观察其发生的上下文。

当然两者的不同从语法上看，方法声明不需要“；”，但是命名方法表达式必须添加“；”

Declarations Versus Expressions: Names and Hoisting：
你应该使用方法声明还是方法表达式？先看看几种不同类型的方法表达式：
type 一：
// this is a function expression,
// pased as an argument to the function `callMe`
callMe(function () {
    // I am an unnamed function expression
    // also known as an anonymous function
});
type 二：
// this is a named function expression
callMe(function me() {
    // I am a named function expression
    // and my name is "me"
});
type 三：
// another function expression
var myobject = {
    say: function () {
        // I am a function expression
    }
};

方法声明只可以出现在global space或者其他方法的方法体中，他们的定义不可以被赋值给变量或者属性，也不可以作为参数传递
In  function  declarations  and  named  function  expressions,  the
nameproperty is defined. In anonymous function expressions, it depends on the implementation;  it  could  be  undefined  (IE)  or  defined  with  an  empty  string  (Firefox,
WebKit):
function foo() {} // declaration
var bar = function () {}; // expression
var baz = function baz() {}; // named expression
foo.name; // "foo"
bar.name; // ""
baz.name; // "baz"

也可能将一个named function expression复制给一个不同名的变量，比如：
var foo = function bar() {};
但是这种表现形式可能不被IE的某些版本浏览器实现，因此建议不要使用这种模式

方法声明会像变量一样被提到作用域的最前面(被提前处理)，不同的是，使用方法声明时，声明的方法名和其方法定义都被提升了地位，但是表达式中只有声明本身被提升了地位，请看下面片段：
// antipattern
// for illustration only
// global functions
function foo() {
    alert('global foo');
}
function bar() {
    alert('global bar');
}
function hoistMe() {
    console.log(typeof foo); // "function"
    console.log(typeof bar); // "undefined"
    foo(); // "local foo"
    bar(); // TypeError: bar is not a function
    // function declaration:
    // variable 'foo' and its implementation both get hoisted
    function foo() {
        alert('local foo');
    }
    // function expression:
    // only variable 'bar' gets hoisted
    // not the implementation
    var bar = function () {
        alert('local bar');
    };
}
hoistMe();

我们知道方法可以作为参数传递，需要注意的问题是其作用域，单纯的将方法变量或者直接匿名传递不存在问题，但是如果传递的方法是某个对象的属性引用，就要注意了，它可能引起意想不到的错误，比如下列实例：

var myapp = {};
myapp.color = "green";
myapp.paint = function (node) {
    node.style.color = this.color;
};
findNodes方法对DOM节点进行hide操作，其does something like this:
var findNodes = function (callback) {
    // ...
    var found = document.getElementById("test");
    if (typeof callback === "function") {
        callback(found);
    }
    // ...
};

上面的findNodes方法中调用paint方法时就会出错，因为this.color是undefined,需要做的是将方法的上下文对象一起传递给方法
var myapp = {};
myapp.color = "green";
myapp.paint = function (node) {
    node.style.color = this.color;
};

var findNodes = function (callback, callback_obj) {
    // ...
    var found = document.getElementById("test");
    if (typeof callback === "function") {
        callback.call(callback_obj, found);
    }
    // ...
};

或者只将方法名的字符串形式传递给方法：findNodes("paint", myapp);

Then findNodes()would do something along these lines:

var findNodes = function (callback, callback_obj) {
    if (typeof callback === "string") {
        callback = callback_obj[callback];
    }
    //...
    if (typeof callback === "function") {
        callback.call(callback_obj, found);
    }
    // ...
};

当向函数传递的参数过多时，为了避免乱了顺序或者参数过多难以read，可以将参数作为一个配置对象传递，避免了上述各种麻烦，也可以进行函数柯里化，下面是一个最终对任何方法进行柯里化的操作：
function schonfinkelize(fn) {
    var slice = Array.prototype.slice,
    stored_args = slice.call(arguments, 1);
    return function () {
        var new_args = slice.call(arguments),
        args = stored_args.concat(new_args);
        return fn.apply(null, args);
    };
}
// a normal function
function add(x, y) {
    return x + y;
}
// curry a function to get a new function
var newadd = schonfinkelize(add, 5);
newadd(4); // 9
// another option -- call the new function directly
schonfinkelize(add, 6)(7); // 13

// a normal function
function add(a, b, c, d, e) {
    return a + b + c + d + e;
}
// works with any number of arguments
schonfinkelize(add, 1, 2, 3)(5, 5); // 16
// two-step currying
var addOne = schonfinkelize(add, 1);
addOne(10, 10, 10, 10); // 41
var addSix = schonfinkelize(addOne, 2, 3);
addSix(5, 5); // 16

11。对象创建

当对象命名空间嵌套比较深或者表现成模块的方式时，最好赋给相应的变量，这样既可以避免过深的对象属性查找，提高性能，也有利于minify，因为可以对变量minify，而对全局命名空间进行进行minify是不安全的，看一下实例：
function test1() {
    alert(MYAPP.modules.m1);
    alert(MYAPP.modules.m2);
    alert(MYAPP.modules.m51);
}
/*
minified test1 body:
alert(MYAPP.modules.m1);alert(MYAPP.modules.m2);alert(MYAPP.modules.m51)
*/
function test2() {
    var modules = MYAPP.modules;
    alert(modules.m1);
    alert(modules.m2);
    alert(modules.m51);
}
/*
minified test2 body:
var a=MYAPP.modules;alert(a.m1);alert(a.m2);alert(a.m51)
*/

特权方法容易出问题的地方：访问值为object、array这种传引用的私有变量，并将其作为返回值。因为外部对返回值的修改其实是修改了私有的变量值。如下：
function Gadget() {
    // private member
    var specs = {
        screen_width: 320,
        screen_height: 480,
        color: "white"
    };
    // public function
    this.getSpecs = function () {
        return specs;
    };
}
var toy = new Gadget(),
specs = toy.getSpecs();

specs.color = "black";
specs.price = "free";
console.dir(toy.getSpecs());

可以看到：getSpecs得到的是:{
    color:"black",
    price: "free",
    screen_height: 480,
    screen_width: 320
}

解决办法是谨慎的传递你想要保持private的object和arrays。比如让getSpecs方法返回一个新的object，此新的object只包含一些用户感兴趣的data，这也是Least Authority原则。要求你never give more than needed。另一个方法是复制object或者array然后返回。

因为构造函数中的私有成员会在每个对象中生成一份，占用内存，所以最好将公共的成员放在prototype中供所有对象共享，并且你可以实现构造中的私有和prototype中对象字面量中的私有，看实例：
function Gadget() {
    // private member
    var name = 'iPod';
    // public function
    this.getName = function () {
        return name;
    };
}
Gadget.prototype = (function () {
    // private member
    var browser = "Mobile Webkit";
    // public prototype members
    return {
        getBrowser: function () {
            return browser;
        }
    };
}());
var toy = new Gadget();
console.log(toy.getName()); // privileged "own" method
console.log(toy.getBrowser()); // privileged prototype method

Revealing private Functions As Public Methods：有时候你希望某个变量是私有的，这样使之可以be protected，但是有时候你又希望其是可以访问的，因为访问它很有用，在ECMA5中可以freeze an object，但是目前不行，那么如何实现这样的目的呢

var myarray;
(function () {
    var astr = "[object Array]",
    toString = Object.prototype.toString;
    function isArray(a) {
        return toString.call(a) === astr;
    }

    function indexOf(haystack, needle) {
        var i = 0,
        max = haystack.length;
        for (; i < max; i += 1) {
            if (haystack[i] === needle) {
                return i;
            }
        }
        return −1;
    }

    myarray = {
        isArray: isArray,
        indexOf: indexOf,
        inArray: indexOf
    };
}());

myarray.isArray([1,2]); // true
myarray.isArray({0: 1}); // false
myarray.indexOf(["a", "b", "z"], "z"); // 2
myarray.inArray(["a", "b", "z"], "z"); // 2

myarray.indexOf = null;
myarray.inArray(["a", "b", "z"], "z"); // 2

Module模式是几种模式的combine：Namespace模式、Immediate functions模式、Private and privileged members模式、Declaring dependencies模式



可以看到通过myarray.isArray，私有的isArray变得public，同时外部对myArray.isArray的修改也不会影响到私有的isArray。


*******************************************************************************
可重用的代码：
-------------
继承是可重用代码的一种实现方式，但不是唯一方式，接下来你会看到怎样通过其他的对象组成新的对象，怎样使用mix-ins对象，怎样只borrow和reuse你需要的功能而不用通过永久继承。而且请记住一点：Prefer object composition to class inheritance

// the parent constructor
function Parent(name) {
    this.name = name || 'Adam';
    this.favorite = ["singing"];
}
// adding functionality to the prototype
Parent.prototype.say = function () {
    return this.name;
};
// empty child constructor
function Child(name) {}

function inherit(C, P) {
    C.prototype = new P();
}

var kid = new Child();
kid.say(); // "Adam"
kid.name = "Patrick";
kid.favorite.push("dancing");
kid.say(); // "Patrick"
console.log(kid.hasOwnPrototype("favorite")); //false 是Child.prototype.favorite === ["singing", "dancing"];
上面的过程中kid首先查找自己的constructor有没有say方法，没有则查找其Constructor的prototype对象(kid的__proto__指向的对象)，此对象有name属性和__proto__属性(指向Parent的prototype对象)，可见没有say方法，继续查找__proto__引用对象，也就是Parent的prototype，有此方法，调用执行。此方法返回this.name,此name又是从kid对象开始在作用域链上进行查找，跟say的查找方式一样

设置kid的name属性并不改变kid的__proto__指向的原型的name属性，而是创建kid对象自己的name属性，接下来调用say方法时跟之前的查找操作一样，只是查找name时直接在kid对象上查找到了，不用在追溯到更高的作用域链了


上面的模式的缺点是将父类实例化对象的自成员添加到了子constructor的prototype上，而且不能通过子constructor传递参数给父类，像下面这样：
var s = new Child('Seth');
s.say(); // "Adam"

下面的方式可以将值传递给父类，但是不能继承父类prototype对象
function Child(a, c, b, d) {
    Parent.apply(this, arguments);
}






汤姆大叔关于js的认识，对我自己的一点补充：

1. 因为ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：

　　函数声明:

　　function 函数名称 (参数：可选){ 函数体 }

　　函数表达式：

　　function 函数名称（可选）(参数：可选){ 函数体 }

所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。

  function foo(){} // 声明，因为它是程序的一部分
  var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分

  new function bar(){}; // 表达式，因为它是new表达式

  (function(){
    function bar(){} // 声明，因为它是函数体的一部分
  })();

还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式

  function foo(){} // 函数声明
  (function foo(){}); // 函数表达式：包含在分组操作符内
  
  try {
    (var x = 5); // 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句
  } catch(err) {
    // SyntaxError
  }

在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval('(' + json + ')')，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。

  try {
    { "x": 5 }; // "{" 和 "}" 做解析成代码块
  } catch(err) {
    // SyntaxError
  }
  
  ({ "x": 5 }); // 分组操作符强制将"{" 和 "}"作为对象字面量来解析

2. 函数声明的实际规则如下：

函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ ... }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 

命名函数表达式需要注意的是：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效。命名函数的用处只是用来调试

    var f = function foo(){
        return typeof foo; // foo是在内部作用域内有效
    };
    // foo在外部用于是不可见的
    console.log(typeof foo); // "undefined"
    console.log(f()); // "function"

    function test(){
        return typeof test;
    } 

    console.log("outer test is : "+ typeof test);
    console.log("inner test is : "+test());

如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子：

  function foo(){
    return bar();
  }
  function bar(){
    return baz();
  }
  function baz(){
    debugger;
  }
  foo();

  // 这里我们使用了3个带名字的函数声明
  // 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了 
  // 因为很明白地显示了名称
  baz
  bar
  foo
  expr_test.html()

  通过查看调用栈的信息，我们可以很明了地知道foo调用了bar, bar又调用了baz（而foo本身有在expr_test.html文档的全局作用域内被调用）

  不过，还有一个比较爽地方，就是刚才说的Firebug为匿名表达式取名的功能：

  function foo(){
    return bar();
  }
  var bar = function(){
    return baz();
  }
  function baz(){
    debugger;
  }
  foo();

  // Call stack
  baz
  bar() //看到了么？ 
  foo
  expr_test.html()

然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号：

  function foo(){
    return bar();
  }
  var bar = (function(){
    if (window.addEventListener) {
      return function(){
        return baz();
      };
    }
    else if (window.attachEvent) {
      return function() {
        return baz();
      };
    }
  })();
  function baz(){
    debugger;
  }
  foo();

  // Call stack
  baz
  (?)() // 这里可是问号哦
  foo
  expr_test.html()

  归根结底，只有给函数表达式取个名字，才是最委托的办法，也就是使用命名函数表达式。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的2个函数的名字都是bar）：

  function foo(){
    return bar();
  }
  var bar = (function(){
    if (window.addEventListener) {
      return function bar(){
        return baz();
      };
    }
    else if (window.attachEvent) {
      return function bar() {
        return baz();
      };
    }
  })();
  function baz(){
    debugger;
  }
  foo();

  // 又再次看到了清晰的调用栈信息了耶!
  baz
  bar
  foo
  expr_test.html()



常量的设置(一种overkill的做法)：
var constant = (function(){
    var constants = {},
        ownProp= Object.prototype.hasOwnProperty,
        allowed = {
            string: 1,
            number: 1,
            boolean: 1
        },
        prefix = (Math.random()+"_").slice(2);
    return {
        set: function(name, value) {
            if(this.isDefined(name)){
                return false;
            }
            if(!owbProp.call(allowed, typeof value)) {
                return false;
            }
            constants[prefix+name] = value;
            return true;
        },
        isDefined: function(name) {
            return ownProp.call(constants, prefix+name);
        },
        get: function(name) {
            if(this.isDefined(name)) {
                return constants[prefix+name];
            }
            return null;
        }
    }
})()


method方法的链式实现类模式，也就是增加原型方法，避免多次创建实例方法，从而占用内存
var Person = function(name) {
    this.name = name;
}.method("getName", function() {
    return this.name;
}).method("setName", function(name) {
    this.name = name;
    return this;
})

if(typeof Function.prototype.method !== "function") {
    Function.prototype.method = function(name, implementation) {
        this.prototype[name] = implementation;// 注意这里的this是构造方法
        return this;
    }
}